# Roll方向调试指南

## 添加的调试日志

### 1. 原始角度检测
- **位置**: `controller.py` -> `compute_twist_from_detection()`
- **日志**: `[ROLL_DEBUG] 原始角度: roll=XXX° | 误差: roll_err=XXX°`
- **作用**: 显示从ArUco检测得到的原始roll角度和计算出的误差

### 2. 角度突变检测
- **日志**: `[ROLL_WARNING] 检测到角度突变！diff=XXX° (上次=XXX° -> 当前=XXX°)`
- **作用**: 检测roll角度是否在连续帧之间发生大幅跳变（>30°）
- **分析**: 如果频繁出现，可能是ArUco检测不稳定

### 3. 死区处理
- **日志**: `[ROLL_DEBUG] 死区处理: 前=XXX° -> 后=XXX° (死区=30°)`
- **作用**: 显示死区处理前后的roll误差变化
- **配置**: `config.yaml` 中的 `deadband_roll_deg: 30.0`

### 4. 振荡检测
- **日志**: `[ROLL_WARNING] 检测到振荡！最近X次误差符号变化X次`
- **作用**: 检测roll误差是否频繁改变符号（来回摆动）
- **分析**: 如果出现，说明控制参数需要调整

### 5. 控制律计算
- **日志**: `[ROLL_DEBUG] 控制律: wx_cam = k_roll(XXX) * roll_err(XXX°) = XXX rad/s = XXX deg/s`
- **作用**: 显示roll角速度命令的计算过程

### 6. 坐标变换
- **日志**: `[ROLL_DEBUG] 坐标变换: w_cam=[wx, wy, wz] -> w_tool=[wx, wy, wz]`
- **作用**: 显示从相机坐标系到工具坐标系的角速度变换
- **分析**: 检查手眼标定矩阵是否正确

### 7. 增量计算和限幅
- **日志**: `[ROLL_DEBUG] 增量计算: delta_rot_x = w_tool_x * dt = XXX rad = XXX°`
- **日志**: `[ROLL_DEBUG] 限幅: 前=XXX° -> 后=XXX° (范数限制=0.1°/tick)`
- **作用**: 显示每个控制周期的roll旋转增量

### 8. 周期性状态输出
- **日志**: `[ROLL_STATUS] 当前状态: roll=XXX° | 最后命令: drx=XXX° | 控制增益: k_roll=XXX`
- **频率**: 每0.24秒（30个控制周期）
- **作用**: 提供roll的整体状态概览

## 关键参数配置

在 `config.yaml` 中：

```yaml
target:
  enable_roll: true   # 启用roll控制

controller:
  k_roll: -0.5   # roll增益（负值）
  max_rot_deg_per_tick: 0.1    # 旋转最大增量（降低防止振荡）
  deadband_roll_deg: 30.0      # roll专用死区（大死区防止振荡）
  enable_lpf: true             # 必须开启低通滤波
  lpf_alpha: 0.3               # 滤波系数
```

## 分析步骤

### 1. 运行程序
```bash
python3 main_vs.py
```

### 2. 启动伺服（按 'S' 键）

### 3. 观察日志输出

#### 场景1: Roll无法收敛，持续摆动
- **现象**: `[ROLL_WARNING] 检测到振荡！`频繁出现
- **可能原因**:
  1. 控制增益 `k_roll` 太大 → 降低到 -0.3 或 -0.2
  2. 死区 `deadband_roll_deg` 太小 → 增加到 40° 或 50°
  3. 旋转限幅 `max_rot_deg_per_tick` 太大 → 降低到 0.05°
  4. 低通滤波未启用或系数太小 → 设置 `enable_lpf: true`, `lpf_alpha: 0.5`

#### 场景2: Roll角度检测跳变
- **现象**: `[ROLL_WARNING] 检测到角度突变！`频繁出现
- **可能原因**:
  1. ArUco检测不稳定（光照、遮挡、模糊）
  2. Tag太小或距离太远
  3. 相机抖动
- **解决**: 增大死区或启用更强的滤波

#### 场景3: Roll误差在死区内但仍有命令
- **现象**: 死区处理后误差为0，但仍有角速度命令
- **可能原因**: 低通滤波器状态未重置
- **解决**: 按 'R' 键重置控制器

#### 场景4: Roll坐标变换异常
- **现象**: `w_cam` 到 `w_tool` 变换后数值异常
- **可能原因**: 手眼标定矩阵错误
- **解决**: 重新进行手眼标定

### 4. 调参建议

如果roll一直摆动，按以下顺序调整：

1. **增大死区** (优先)
   ```yaml
   deadband_roll_deg: 40.0  # 从30增加到40
   ```

2. **降低增益**
   ```yaml
   k_roll: -0.3  # 从-0.5降低到-0.3
   ```

3. **降低限幅**
   ```yaml
   max_rot_deg_per_tick: 0.05  # 从0.1降低到0.05
   ```

4. **增强滤波**
   ```yaml
   lpf_alpha: 0.5  # 从0.3增加到0.5（更平滑）
   ```

5. **如果仍然摆动，考虑临时禁用roll**
   ```yaml
   enable_roll: false
   ```

## 典型日志示例

### 正常收敛
```
[ROLL_DEBUG] 原始角度: roll= +15.30° | 误差: roll_err= +15.30°
[ROLL_DEBUG] 死区处理: 前= +15.30° -> 后= +0.00° (死区= +30.00°)
[ROLL_DEBUG] 控制律: wx_cam = k_roll(-0.5) * roll_err( +0.00°) = +0.0000 rad/s = +0.00 deg/s
```
→ 误差在死区内，无命令输出，正常

### 振荡情况
```
[ROLL_DEBUG] 原始角度: roll= +12.50° | 误差: roll_err= +12.50°
[ROLL_DEBUG] 控制律: wx_cam = ... = +0.1091 rad/s = +6.25 deg/s
[控制周期后]
[ROLL_DEBUG] 原始角度: roll= -8.30° | 误差: roll_err= -8.30°
[ROLL_WARNING] 检测到振荡！最近10次误差符号变化4次
```
→ roll在正负之间来回摆动，需要调整参数

### 角度跳变
```
[ROLL_DEBUG] 原始角度: roll= +15.30° | 误差: roll_err= +15.30°
[控制周期后]
[ROLL_DEBUG] 原始角度: roll= -45.20° | 误差: roll_err= -45.20°
[ROLL_WARNING] 检测到角度突变！diff=-60.50° (上次=+15.30° -> 当前=-45.20°)
```
→ ArUco检测不稳定，考虑改善检测条件或增大滤波

## 物理原因分析

Roll方向难以收敛的可能原因：

1. **手眼耦合**: roll旋转会导致相机视角大幅变化，影响ArUco检测精度
2. **机械刚性**: 机械臂末端绕自身轴旋转的刚性可能较低
3. **控制延迟**: 视觉30Hz + 控制125Hz，存在延迟累积
4. **奇异点**: 某些姿态下roll与其他轴耦合

## 进一步排查

如果以上方法仍无法解决，可以：

1. **记录完整轨迹**: 修改代码记录roll角度、误差、命令的时间序列
2. **绘制曲线**: 用matplotlib绘制roll随时间变化曲线，分析振荡周期
3. **降采样控制**: 将roll控制频率降低（每N个周期更新一次）
4. **分离控制**: 先收敛xyz和yaw/pitch，最后再控制roll

## 总结

通过这些详细日志，你可以：
- 确认ArUco检测的roll角度是否稳定
- 观察死区是否合理
- 检查控制律计算是否正确
- 发现坐标变换是否有问题
- 识别振荡模式
- 调整控制参数

祝调试顺利！
